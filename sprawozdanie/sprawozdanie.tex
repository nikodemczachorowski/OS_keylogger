\documentclass{article}
\usepackage{graphicx, float}
\usepackage{subfig}
\usepackage{slashbox}
\usepackage{polski}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}

\usepackage[margin=2.5cm]{geometry}

\lstset{
    language=C,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!50!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    frame=single,
    breaklines=true,
    captionpos=b,
    tabsize=4,
    showstringspaces=false
}

\graphicspath{img}

\title{Oprogramowanie Systemowe - Keylogger}
\author{Nikodem Czachorowski 197907}

\begin{document}
    \maketitle

    \section{Wstęp}
        Celem projektu było zaimplementowanie keyloggera działającego w systemie Windows, jako sterownik urządzenia klawiatury. 
        Do implementacji został użyty framework KMDF.

    \section{Środowisko Programistyczne}
        Sterownik był pisany w Visual Studio, które ułatwia wiele czynności związanych z wdrażaniem i testowaniem.
        Wszystkie niezbędne pliki były automatycznie kopiowane na maszynę testową.
        
        Do testów posłużyła maszyna wirtualna z zainstalowanym systemem Windows 11. 
        Na maszynie testowej konieczne było zainstalowanie WDK, uruchomienie w niej trybu debugowania. 
        Aby komunikaty wypisywane za pomocą funkcji DbgPrint() były wyświetlane w debugerze, konieczne było rówież dodanie klucza o nazwie DEFAULT w rejestrze \verb|HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter| o wartości 0xFFFFFFFF.

        
        Debugowanie odbywało się za pomocą WinDbg podłączonego do maszyny wirtualnej przez sieć. 
        Proces łączenia maszyny testowej z debugerem został znacząco ułatwiony przez Visual Studio, które po podaniu nazwy maszyny testowej i adresu ip samo skończyło konfigurację połączenia.

    \section{Architektura}
        Mój keylogger składa się z dwóch częsci - sterownika działającego w trybie jadra oraz aplikacji działającej w trybie urzytkownika.

        Zadaniem stereownika było zbieranie wciśnietych klawiszy oraz przesyłanie ich do aplikacji trybu urzytkownika.
        Przy starcie systemu tworzył dwa urządzenia. Sterownik ma kontekst, do którego sostęp mają oba urządzenia. Ma on następującą struktórę:
        \begin{lstlisting}[caption = {Struktura kontekstu sterownika}, label={lst:driver_context}]
            typedef struct _DRIVER_CONTEXT {
                KEY_EVENT_DATA buffer[BUFFER_SIZE];
                ULONG Head;
                ULONG Tail;
                WDFSPINLOCK BufferLock;

                WDFQUEUE AppQueue;
            } DRIVER_CONTEXT, * PDRIVER_CONTEXT;
        \end{lstlisting}
        Pierwsze z urządzeń działało jako górny filtr klawiatury.
        Po starcie sterownik nasłuchuje sygnałów przechodzących przez stos sterowników klawiatury.
        W momencie przechwycenia komunikatu \verb|IOCTL_INTERNAL_KEYBOARD_CONNECT|, sterownik wpisuje do niego swój callback i od tego momentu wszystkie wciśnięte klawisze będą przechodzić przez podany callback.
        Funkcja callback czyta wciśnięte klawisze i wpisuje je do bufora. Dane zapisywane w buforze mają następujący format:
        \begin{lstlisting}[caption = {Struktura przechowująca pojedynczy klawisz}, label={lst:key_event_data}]
            typedef struct _KEY_EVENT_DATA {
                unsigned short MakeCode;
                unsigned short Flags; 
            } KEY_EVENT_DATA, * PKEY_EVENT_DATA;
        \end{lstlisting}
        Drugim urządzeniem w sterowniku jest urządzenie kontrolne, które zajmuje sie komunikacją z aplikacja urzytkowika.
        Jedynym zadaniem tego urządzenia jest reagowanie na nowe komunikaty od aplikacji i odpowiadanie na nie klawiszami z bufora jesli są dostępne.

        Aplikacja w trybie urzytkownika zajmuje się zmianą scancodeów otzrymanych od sterownika na tekst i zapisywanie ich w pliku.
        Komunikacja odbywa się przez plik \verb|\\.\OS_keyloggerLink|. Aplikacja wrzuca do niego swoje rządanie i czeka na odpowiedź.
        Po uzyskaniu odpowiedzi scancode oraz flaga są zapisywane do pliku, następnie ją zamieniane za Znak, który reprezentują i wpisywane do drugiego pliku.
        Zamiana ze scancode na znak następuje przy pomocy lookup table, która jako indeksu urzywa scancodeu, a wartością jest struktóra zawierająca znak zwykły oraz znak po wciśnięciu shifta.

    \section{Zarządzanie zasobami}
        W KMDF sterowniki mają strukturę hierarchiczną.
        Głównym obiektem w moim sterowniku jest WDFDRIVER, który jest rodzicem dla obu tworzonych obiektów WDFDEVICE - filtru klawiatury i urządzenia kontrolnego.
        Aby miec dostęp do zmiennych z różnych funkcji sterownika należy dodać je do kontekstu.
        Praktycznie wszystkie obiekty w KMDF mogą mieć swój własny kontekst do którego mogą zapisywać potrzebne im dane. 
        W moim sterowniku konteksty posiadają WDFDRIVER \ref{lst:driver_context} oraz WDFDEVICE reprezentujący filtr klawiatury, który zapisuje w nim gdzie przesłać dalej klawisze, gdy już skończy je przetważać.
        Dzięki temu, że bufor na klawisze znajduje się w kontekście sterownika, oba urządzenia mogą uzyskać dostęp do tej pamięci.
        Jako, że dwa urządzenia działające niezalerznie od siebie mają dostęp do tych samych danych trzeba było wpraowadzić sposób zarządzaniem dostępu do nich.
        System windows nie pozwala usypiać wątków, które działają jako przerwania, więc nie można było wykożystać klasycznego semafora.
        Zamiast tego, trzeba było skorzystać ze spinlocka, który zamiast usypiać wątek wprowadza go w stan aktywnego oczekiwania, co oznacza, że wątek w pętli pyta o dostęp do zasobu, aż go nie dostanie.

    \section{Debuggowanie i analiza}
    \section{Testy i rezulataty}
    \section{Problemy napotkane w trakcie realizacji}
        \subsection{Dopisywanie się do UpperFilers klawiatury} \label{sec:UpperFilters_regedit}
            Aby wpisać swój callback do stosu klawiatury trzeba odebrać rządanie \verb|IOCTL_INTERNAL_KEYBOARD_CONNECT| i dopisać swoją funkcję.
            Aby to rządanie w ogóle trafiło do sterownika, mósi on być wpisany nad kbdclass w UpperFilers w \verb|HKLM\SYSTEM\CurrentControlSet\Control\Class\{4d36e96b-e325-11ce-bfc1-08002be10318}|.
            Jeśli sterownik będzie pod kbdclass, oczekiwane rządanie nigdy do niego nie dotrze.
            Problem leży w tym, że w pliku .inf podczas edytowania rejestrów nie można wybrać na której pozycji wpisać dodawaną wartość.
            Jedynymi opcjami są 0x00010000 \verb|(FLG_ADDREG_TYPE_MULTI_SZ)|, zastępująca obecną wartość rejestru, oraz 0x00000008 \verb|(FLG_ADDREG_APPEND)|, dopisująca na koniec obecnaj wartości.

            Moje rozwiązanie tego problemu jest bardziej obejściem niż rzeczywistym rozwiązaniem.
            Na początku chciałem najpierw usunąć wpis kbdclass z UpperFilters, dopisać na koniec mój sterownik, a następnie dopisać z powrotem kbdclass.
            Takie podejście okazało się niemożliwe, ponieważ plik .inf z takim rozwiązaniem nie przechodził validacji.
            Ostatecznie zdecydowałem się zastępować całą obecną wartość moim sterownikiem na początku i kbdclass na końcu.
            Nie jest to rozwiązanie dobre, ponieważ jeśli w wartości były jeszcze inne wpisy, zostaną one usunięte.
        
        \subsection{Przekazywanie klawiszy między sterownikiem, a aplikacja urzytkownika}
            W celu przekazywania informacji między sterownikiem, a  aplikacją trybu urzytkownika trzeba stworzyć dowiązanie symboliczne.
            Działa to jak plik, do którego informacje mogą zapisywać zarówno aplikacja, jak i sterownik.
            Problem polegał na tym, że system windows nie pozwolił aplikacji urzytkownika na otworzenie dowiązania symbolicznego stworzonego przez filtr klawiatury.
            Wywołanie funkcji CreateFile kończyło się błędem 0x5 \verb|ERROR_ACCESS_DENIED|.

            Any naprawić ten błąd dodałem do sterownika nowe urządzenie.
            Jego jedynym zadaniem było odbieranie rządań od aplikacji urzytkownika i odpowiadanie na nie klawiszami z bufora.

        \subsection{Dodanie aplikacji trybu urzytkownika do autostartu}
            Z powodu tego, że zapis do pliku ma miejsce w aplikacji urzytkownika, trzeba ją uruchomić aby sterownik był funkcjonalny poza debugerem.
            Chciałem dodać aplikację urzytkownika do autostartu dodając wpis w rejestrze za pomocą pliku .inf.
            Aby to zrobić musiałbym dodać ścierzkę do pliku wykonywalnego aplikacji do rejestru \verb|HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run|.

            Problemem ponownie okazała się validacja pliku .inf. Plik ten z założenia powinien instalować tylko sterownik. 
            Z tego powodu nie pozwala na edycję niektórych rejestrów.
            Ostatecznie nie udało mi się rozwiązać tego problemu.
            Jeśli chcę aby aplikacja uruchamiała się przy starcie systemu muszę ręcznie dodać wpis do rejestru.
            Najlepszym wyjście z tej sytuacji najprawdopodobniej byłby osobny skrypt instalacyjny.
            Takie podejście rozwiazało by również problem \ref{sec:UpperFilters_regedit}.

    \section{Podsumowanie i wnioski}
\end{document}